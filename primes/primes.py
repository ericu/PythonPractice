#!/usr/bin/python
import numpy as np

# ..................................................
# ..................................................
# ..................................................
# ..................................................
# ..................................................
# ..................................................
# ..................................................
# ..................................................
# ..................................................
# .....................54444........................
# .....................53224........................
# .....................53124........................
# .....................53124........................
# .....................53334........................
# .....................55555........................
# ..................................................
# ..................................................
# ..............................544446..............
# ..............................532246..............
# ..............................531246..............
# ..............................531246..............
# ..............................533346..............
# ..............................555556..............
# ..................................................
# ..................................................
# ..................................................
# ..................................................

# Sieve code adapted from
# https://code.activestate.com/recipes/117119-sieve-of-eratosthenes/ which is
# licensed under the PSF license.
def sieve(up_to):
    composites = {}
    cur = 2
    primes = []
    while cur < up_to:
        if cur not in composites:
            primes.append(cur)
            composites[cur * cur] = [cur]  # Cur is the only factor of cur^2.
        else:
            for factor in composites[cur]:
                composites.setdefault(cur + factor, []).append(factor)
            del composites[cur]
        cur += 1
    return primes


def spiral_out(square_size):
    """This generates a list of coordinates spiraling outward,
    counterclockwise, from the center of a square.  It terminates when it's
    covered the whole square."""
    halfway = (square_size + 1) // 2 - 1
    coords = np.array([halfway, halfway])
    vector = np.array([1, 0])
    rotate = np.array([[0, -1], [1, 0]])
    for edge_size in range(1, square_size + 1):
        for _ in [0, 1]:
            for _ in range(edge_size):
                yield np.copy(coords)
                coords += vector
            if edge_size == square_size:
                return
            vector = rotate.dot(vector)


def map_primes(square_size):
    count = square_size * square_size
    display = np.zeros([square_size, square_size])
    primes = set(sieve(count + 2))
    generator = spiral_out(square_size)
    for i in range(2, count):
        coords = next(generator)
        if i in primes:
            display[tuple(coords)] = i
    return display


if __name__ == "__main__":
    print(map_primes(4))
