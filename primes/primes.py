#!/usr/bin/python
import numpy as np

#..................................................
#..................................................
#..................................................
#..................................................
#..................................................
#..................................................
#..................................................
#..................................................
#..................................................
#.....................54444........................
#.....................53224........................
#.....................53124........................
#.....................53124........................
#.....................53334........................
#.....................55555........................
#..................................................
#..................................................
#..............................544446..............
#..............................532246..............
#..............................531246..............
#..............................531246..............
#..............................533346..............
#..............................555556..............
#..................................................
#..................................................
#..................................................
#..................................................

# Sieve code adapted from
# https://code.activestate.com/recipes/117119-sieve-of-eratosthenes/ which is
# licensed under the PSF license.
def sieve(up_to):
  composites = {}
  cur = 2
  primes = []
  while cur < up_to:
    if cur not in composites:
      primes.append(cur)
      composites[cur * cur] = [cur] # Cur is the only factor of cur^2.
    else:
      for factor in composites[cur]:
        composites.setdefault(cur + factor, []).append(factor)
      del composites[cur]
    cur += 1
  return primes

def spiral_out(square_size):
  halfway = (square_size + 1) // 2 - 1
  coords = np.array([halfway, halfway])
  vector = np.array([1, 0])
  rotate = np.array([[0, -1], [1, 0]])
  phase_counter = 0
  pos_counter = 0
  for edge_size in range(1, square_size + 1):
    for phase_counter in [0, 1]:
      for pos_counter in range(edge_size):
        yield np.copy(coords)
        coords += vector
      if edge_size == square_size:
        return
      vector = rotate.dot(vector) # TODO: Possibly needs the other order?




if __name__ == "__main__":
    print([a for a in spiral_out(1)])

